# [Контест (Шаблоны + Длинная Арифметика)](https://contest.yandex.ru/contest/35021/enter/?retPage=)

## Задача 1 (Бинпоиск. Шаблоны)

### Условие
Пришлите заголовочный файл с определениями трех шаблонных функций для работы с отсортированными последовательностями. Каждая функция принимает три аргумента: $begin$ - указатель на начало последовательности, $end$ - указатель на конец последовательности (элемент следующий за последним), $value$ - запрос.

- ***BinarySearch***
	- функция, осуществляющая проверку наличия элемента $value$ в отсортированной последовательности $[begin,end)$. Возвращает $true$, если и только если на полуинтервале $[begin,end)$ имеется значение $value$.

- ***LowerBound***
	- функция, осуществляющая поиск первого элемента не меньшего $(≥)$ $value$ на полуинтервале $[begin,end)$. Возвращает указатель на найденный элемент, либо $end$, если такого нет.

- ***UpperBound***
	- функция, осуществляющая поиск первого элемента строго большего $(>)$ $value$ на полуинтервале $[begin,end)$. Возвращает указатель на найденный элемент, либо $end$, если такого нет.

**Важно:** используйте только сравнение на меньше $(<)$ и избегайте лишних копирований элементов. То есть считайте, что элементы последовательности не копируемы и могут быть сравнены только с помощью операции $<$.

**Пример**

int array[5]{1, 2, 3, 3, 5};

BinarySearch(array + 3, array + 4, 2); // false

LowerBound(array + 1, array + 5, 3); // указатель на 2й элемент

UpperBound(array, array + 2, 4); // указатель на 2й элемент (на [0, 2) такого элемента нет)

### Формат ввода 
**Данная информация нужна только для понимания примера. Обработку пользовательского ввода писать не нужно. Вместо указателей в примере вводятся и выводятся индексы элементов.**

На первой строчке подается число элементов в последовательности, а далее сами элементы.

В следующих строках следует число запросов и сами запросы в формате (begin, end, value).


### Формат вывода

**Данная информация нужна только для понимания примера. Ваши функции ничего выводить не должны.**

Выводятся 3 числа - результаты вызова BinarySearch, LowerBound и UpperBound соответственно.

**Пример** 
| **Ввод**  | **Ввывод** |
|-----------|------------|
| 5         | NO 3 3     |
| 1 2 3 4 5 | YES 2 3    |
| 5         | NO 4 4     |
| 0 3 4     | YES 0 1    |
| 0 3 3     | YES 4 5    |
| 1 5 6     |            |
| 1 2 2     |            |
| 0 5 5     |            |

## Задача 2 (Слияние. Шаблоны)

### Условие
Реализуйте шаблонную функцию Merge, которая принимает две отсортированные последовательности и сливает их одну большую отсортированную.

Функция должна принимать 5 аргументов: first_begin, first_end - указатели на начало и конец первой последовательности; second_begin, second_end - начало и конец второй последовательности; out - указатель на начало итоговой последовательности (куда записывать ответ).

Последовательности first, second и out могут хранить значения разных типов!

**Пример**

int16_t first[2]{1, 4};

int32_t second[3]{2, 3, 5};

int64_t out[5];

Merge(first, first + 2, second, second + 3, out); // out = {1, 2, 3, 4, 5}

Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".

Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).

| **Ввод** | **Ввывод**    |
|----------|---------------|
| 3        | 1 2 3 4 5 6 7 |
| 1 4 6    |               |
| 4        |               |
| 2 3 5 7  |               |

## Задача 3 (Сортировка. Шаблоны)

### Условие
В данной задаче вам необходимо реализовать шаблонную функцию Sort, сортирующую переданную последовательность. Функция должна принимать два аргумента: begin - указатель на начало последовательности, end - указатель на конец последовательности (элемент следующий за последним).

**Пример**

int array[5]{3, 5, 1, 4, 2};

Sort(array + 1, array + 4); // array = {3, 1, 4, 5, 2}

Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".

Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).

### Формат ввода 
**Данная информация нужна только для понимания примера. Обработку пользовательского ввода писать не нужно. Вместо указателей в примере вводятся и выводятся индексы элементов.**

На первой строчке подается число элементов в последовательности, а далее сами элементы.

В следующих строках следует число запросов и сами запросы в формате (begin, end, value).


### Формат вывода
На вход подается массив размера $n≤10^5$.

**Пример** 
| **Ввод**  | **Ввывод** |
|-----------|------------|
| 5         | 1 2 3 4 5  |
| 5 2 3 1 4 |            |


## Задача 4 (k-я порядковая статистика. Шаблоны)

### Условие
Реализуйте шаблонную функцию KthElement, которая упорядочивает элементы последовательности так, чтобы на k-м месте (в 0 индексации) стоял k-й по величине элемент последовательности.

Функция должна принимать 3 аргумента: begin - указатель на начало последовательности; kth - указатель на k-ю позицию; end - указатель на конец последовательности.

Среднее время работы алгоритма должно быть линейным от длины полуинтервала *[begin, end)*.

**Пример**

int array[5]{2, 3, 5, 4, 1}

KthElement(array, array + 2, array + 5); // array = {1, 2, 3, 5, 4}

Ваш код будет проверяться на скрытых от вас юнит-тестах, проверяющих корректность шаблонной реализации. Требование к реализации: из операций сравнения можно использовать только операцию "<".

Пришлите на проверку заголовочный файл, содержащий ТОЛЬКО определение шаблона. Он будет включен в cpp файл с тестами автоматически (main писать не нужно!).
 
| **Ввод**  | **Ввывод** |
|-----------|------------|
|2 2 100 1000|   1000    |


## Задача 5 (A+B)

### Условие
Речь идёт о 10000-значных суммах...


### Формат ввода 
Во входном файле два целых неотрицательных числа A и B $(0 ≤ A, B ≤ 10^10000)$ каждое в своей строке.


### Формат вывода
В выходной файл выведите одно число, равное сумме A и B.

**Пример** 
| **Ввод**  | **Ввывод** |
|-----------|------------|
| 3         | 8          |
| 5         |            |


## Задача 6 (A-B)

### Условие
Лапидарно.


### Формат ввода 
Во входном файле два целых неотрицательных числа A и B $(0 ≤ A, B ≤ 10^10000)$ каждое в своей строке.


### Формат вывода
В выходной файл выведите одно число, равное разности A и B.

**Пример** 
| **Ввод**  | **Ввывод** |
|-----------|------------|
| 5         | 2          |
| 3         |            |


## Задача 7 (A-B)

### Условие
В этой задаче от вас требуется реализовать умножение (https://en.wikipedia.org/wiki/Multiplication).


### Формат ввода 
Во входном файле два целых неотрицательных числа A и B $(0 ≤ A, B ≤ 10^10000)$ каждое в своей строке.


### Формат вывода
В выходной файл выведите одно число, равное произведению A и B.

**Пример** 
| **Ввод**  | **Ввывод** |
|-----------|------------|
| 65536     | 14155776   |
| 216       |            |